<!DOCTYPE html><!--[if lt IE 7]>
<html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]--><!--[if IE 7]>
<html class="no-js lt-ie9 lt-ie8"> <![endif]--><!--[if IE 8]>
<html class="no-js lt-ie9"> <![endif]--><!--[if gt IE 8]><!-->
<html class="no-js"> <!--<![endif]-->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Address Stories</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

    <link rel="stylesheet" href="css/normalize.css">
    <link rel="stylesheet" href="css/main.css">
    <script src="js/vendor/modernizr-2.6.2.min.js"></script>
</head>
<body>
<!--[if lt IE 7]><p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a
    href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p><![endif]-->

<h1>Address Stories</h1>

<h4>This is currently in a very rough draft state...</h4>

<p>Initially, we want to do the vendor stories. This means handling the addresses for vendors, so we need to work out
    general requirements and validation for addresses. In general, we don't want to force validation on our customers,
    the addresses are too varied and it will just cause problems. We do want to be able to give our customers pluggable
    validation ability if they request it though.</p>

<p>We need to model out the address and phone number. You might initially think that everything should be in Strings for
    the fields - for example, Street Address, Locality (City), etc. Take a look at the <a
        href="http://c2.com/cgi/wiki?PrimitiveObsession">Primitive Obsession</a> smell. In general, you should not use
    primitives (and primitives include Strings) for objects. If you want to take this concept to extreme, you should
    read the the <a href="http://www.cs.helsinki.fi/u/luontola/tdd-2009/ext/ObjectCalisthenics.pdf">object
        calisthenics</a> document. The calisthenics document is very extreme, so in general I don't follow it to the
    letter. But it does have some really good ideas to think about. </p>

<p>So for each of the types in the address we will use a class:
<ul>
    <li>Locality (City)</li>
    <li>Region (State)</li>
    <li>Postal Code</li>
    <li>Country</li>
</ul>
Since we want this to be international application we are going to need pluggable validation on the address objects.</p>

<p>Initially we want to support the G20 countries, since they have the most money. So this means we need to support
    their addresses, and if there are vendors that are from countries that supply the G20 but aren't part of it, then we
    should be able to support those too. This might open things up too much, but for now, we'll stick with G20.</p>

<p>We're only going to worry about 3 of the countries for now, which will hopefully give us enough variety that we can
    handle changes in the future. We will use the following countries (with links to their address information):
<ul>
    <li>United States - <a href="http://www.upu.int/fileadmin/documentsFiles/activities/addressingUnit/usaEn.pdf">http://www.upu.int/fileadmin/documentsFiles/activities/addressingUnit/usaEn.pdf</a>
    </li>
    <li>China - <a href="http://www.upu.int/fileadmin/documentsFiles/activities/addressingUnit/chnEn.pdf">http://www.upu.int/fileadmin/documentsFiles/activities/addressingUnit/chnEn.pdf</a>
    </li>
    <li>Germany - <a href="http://www.upu.int/fileadmin/documentsFiles/activities/addressingUnit/deuEn.pdf">http://www.upu.int/fileadmin/documentsFiles/activities/addressingUnit/deuEn.pdf</a>
    </li>
</ul>
Since we want to have pluggable validation, we'll develop the validation for these three countries - but have it turned
off by default. The validation is only going to be based on the documents linked above for the most part. We will assume
that we can validate any part of an address in a pluggable fashion, even if we don't based on the 3 countries listed
above.</p>

<p>We have to validate the address commands we create and optionally any input on the users end, because we can't
    validate the events - this is how you have to handle any validation when working with Axon. This is a very important
    concept to understand. The events just have to be applied to the aggregates, they can't be rejected. Imagine what
    would happen if you originally applied an event to an aggregate, and then for whatever reason didn't apply it when
    the events were being replayed from the event store. Now you've got a real problem, the event stream is invalid,
    what would you do? Start the whole system over and erase everything? So you have to be able to apply any events once
    the commands are processed and the events are created. If you discover that an event is invalid, you have to create
    a <a href="http://blog.jonathanoliver.com/cqrs-event-sourcing-and-immutable-data/">compensating event</a> to undo
    whatever the event changed that was wrong. </p>

<p>While our domain objects are encapsulate Strings, the commands do not, so the validators will need to handle Strings.
    Below is an initial cut at a CreateAddressCommand. We can't really use any Bean Validation / Hibernate Validation
    annotations because we don't have any hard and fast validations, as noted above. We also can't use the XML
    configuration from Hibernate Validator because it only allows a class to be configured once for validation - so we
    couldn't have one validation for the US and one for China. We also want to be able to use the same validation on the
    front end if at all possible.</p>

<pre class="prettyprint">
public class CreateAddressCommand {
    private String addressLines;
    private String locality;
    private String region;
    private String postalCode;
    private String countryCode;

    public CreateAddressCommand() {}

    public String getAddressLines() { return addressLines; }
    public void setAddressLines( final String addressLines ) { this.addressLines = addressLines; }
    public String getLocality() { return locality; }
    public void setLocality( final String locality ) { this.locality = locality; }
    public String getRegion() { return region; }
    public void setRegion( final String region ) { this.region = region; }
    public String getPostalCode() { return postalCode; }
    public void setPostalCode( final String postalCode ) { this.postalCode = postalCode; }
    public String getCountryCode() { return countryCode; }
    public void setCountryCode( final String countryCode ) { this.countryCode = countryCode; }
}
</pre>

<p>If we want to be able to validate different objects with the same validation, we generally are going to want to have
    an Interface that our validator can use. So we will go ahead and extract an interface off the CreateAddressCommand.
    Then we can start to build a our validators and see what kind of commonalities they have.</p>

<p>A question to consider is: Should we have an interface for each Class? In other words, should there be a validator
    for the AddressLines, Locality, Region, etc? Or should there just be one validator that handles the entire Address
    String interface? Since we are considering pluggable validation, and that the validation can be different for each
    class depending on the Country, I'm thinking that we should have an overall address interface, as well as interfaces
    for each individual class. This follows the <a
        href="http://en.wikipedia.org/wiki/Interface_segregation_principle">Interface Segregation Principle</a> that a
    class shouldn't have to depend on an interface that has more methods than the class needs. In other words, if you
    have a PostalCode validator class, and the only thing the validator needs is a Postal Code to do its validation,
    then it shouldn't be working with the entire Address interface that includes a bunch of other methods.</p>

<p>address lines, locality, region, postal code, country code? Has address</p>

<p> how do we know what to pass the validator? In other words how do we know which interfaces it is interested in. Our
    choices are reflection, interface implementation or annotations reflection in this case means going through an
    entire class to find methods that take a particular has interface: this doesn't seem like a good idea because it
    could pick up a method that is it really meant for validation but just takes one of the has interface classes as a
    parameter that leaves us with interface implementation and annotations I'm leaning towards interface implementation
    because it is more explicit.</p>

<p>Examples: ValidatesAddress, ValidatesLocality, etc. [ValidatesAddressComponent as a "parent" interface (don't like
    the Component part of the name.</p>

<p> So the next decision is how to know when to apply a particular validator against a particular address the following for example could come into play:
<ul>
    <li>Country Code - the validator is designed for US addresses only.</li>
    <li>Context of Address -  we might have different validation for vendors versus customers versus ?</li>
    <li> Other address values – specific validator for certain cities or regions.</li>
</ul></p>

<p> One option would be to let the validator itself decide, but that breaks the single responsibility principle in the
    sense that the validator is deciding what to validate along with doing the validation. I'm not sure that that's a
    big deal though we might end up doing that will see.</p>

<p> so it looks like there needs to be a separate ContextAwareAddressValidator. not sure if I like that name. The
    context aware address validator will have the validate address and validate address, context methods which will
    return the same values as a JSR 303 Bean validator. Of course this is actually an interface. we are going to need to
    register validator's with this selector, along with a way to specify when the validator should apply. If you decide
    that the validator itself should decide whether or not to validate then simply set up the chooser to always run that
    particular validator the validator can then actually do the validation based on the addresses it wants to run them
    on if he chooses not to validate an address it just doesn't do anything.</p>

<p>there needs to be the ability to run multiple validator's foreign address not just one.</p>

<pre class="prettyprint">
    selector.addValidator( ValidatesAdddressComponent validator );
    selector.addContextSpecificValidator( validator, { contexts? } );
</pre>

<p> Not sure how to handle the contexts, some type of outside object (or closure); or an enum. Would prefer to not use
    an enum, because that generally will violate the Open Closed Principal. This is because to add a new context we
    would have to basically add a new a new value. Whereas if we can figure out a way to do it with an interface or a
    closure than we basically just have to add a new closure to the code somewhere and we don't have to open up the enum
    and anything that depends on it. </p>

<p> the next question is how do the validator's return errors and/or warnings/messages. If possible it's always best to
    stay compatible with existing standards, so let's see if we can make our design compatible with standard Java
    validation hibernate validator for example.</p>

<p> the next thing we need to decide is where to hook the validator in the axon. This probably should be handled using a
    command dispatch interceptor at a link to that in the documents for axon. See the axon docs for how standard being
    validation on commands is handled and hooked into the command chain within a handle ours in a similar manner.</p>

<p> So do we need an annotation on commands that should have address validation performed? With the annotation include
    the context? Probably not if we're not using an enum. Or should this be handled programmatically hopefully it's
    obvious I'm leaning towards programmatically.</p>

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="js/vendor/jquery-1.10.2.min.js"><\/script>')</script>
<script src="js/plugins.js"></script>
<script src="js/main.js"></script>
<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>

<script>
    (function (b, o, i, l, e, r) {
        b.GoogleAnalyticsObject = l;
        b[l] || (b[l] =
            function () {
                (b[l].q = b[l].q || []).push(arguments)
            });
        b[l].l = +new Date;
        e = o.createElement(i);
        r = o.getElementsByTagName(i)[0];
        e.src = '//www.google-analytics.com/analytics.js';
        r.parentNode.insertBefore(e, r)
    }(window, document, 'script', 'ga'));
    ga('create', 'UA-48307574-1');
    ga('send', 'pageview');
</script>
</body>
</html>
